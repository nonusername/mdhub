---
title: 小结1
renderNumberedHeading: true
grammar_cjkRuby: true
---

# DSST

现有方法的缺陷：在复杂图片序列中，尺度变化大时检测效果差，或是因速度慢而不适用于实时监测。
DSST可以解决尺度变化问题，并且分别学习平移滤波器和尺度滤波器。
基础：the discriminative correlation filters employed in the MOSSE、HOG
改进：扩展到多维特征、提出了尺度估计方法
           （通过分别更新滤波器的分子与分母，减少计算复杂度。位置滤波器为2维，尺度滤波器为1维）
		   

多维特征：原有的滤波器的t时刻系数ht是由，以1-t时所有的灰度图计算得到的损失函数为基础，多维的损失函数，则是以1个训练样本的多个特征图为基础的，并且随着t的更新而更新。
尺度估计：训练一个M * N * S 的filter，S代表尺度的数量。
                  训练样本f，是以上一帧确定的位置为中心，取得一系列不同尺度的图像块的特征。

加速：分别学习位置滤波器和尺度滤波器（减小尺度滤波器的搜索范围）
           由于尺度差异通常小于平移差异，所以先使用平移滤波器，再用尺度滤波器。

流程：
迭代次数 t
输入: 图片It  之前的目标位置Pt-1与尺度St-1，平移模型和尺度模型的分子、分母
输出：当前的目标位置Pt与尺度St，更新后的平移模型和尺度模型的分子、分母
平移估计：根据Pt-1和St-1选取平移样本，计算y，取y最大的位置Pt
尺度估计：根据Pt和St-1选取尺度样本，计算y，取y最大的St
模型更新：根据Pt和St取平移样本和尺度样本，更新模型参数

# MUSTER
现有的short-term方法：记录一组目标样例、判别目标与背景、给样本贴标签、相关过滤
问题：只能处理短期tracking
现有的long-term方法：用自适应步长的学习方法挑选可信度高的帧学习目标外观、过采样等

MUSTER:把生物学记忆的模式结合到tracking中。
基础： ASMM记忆模型,ICF,遗忘曲线,RANSAC。

ASMM：sensory memory，短期记忆，长期记忆。
              当有一个特别的模式被反复地接收，长期记忆就会被激活，模式信息被保存。但如果不被加强，则会被遗忘。
               当模型遇到了一个突变时，记住的信息会被从长期记忆中去除，来稳定输出。

short-term 部分：利用ICF、短期记忆、时空连续性进行tracking
long-term 部分: 关键点匹配tracking、RANSAC
long-term 部分与短期记忆（关键点）交互、利用长期记忆做matching、根据RANSAC与遗忘曲线更新长期记忆
两部分的输出传给一个控制器，控制器决定最后的输出与ICF的更新.
当short-term的输出与长期记忆非常不连续时，ICF中的短期记忆会被重置。

 Short-term Integrated Correlation Filters：
ICF:一个分为两阶段的滤波过程，平移估计和尺度估计。
第一阶段：以KCF为基础，为了适应短期追踪时目标外观的变化，设定一个学习率改变参数。
第二阶段：尺度估计。和DSST差不多。

Short-term Processing of Keypoints：
long-term的部分是为了学习目标外观并在short-term检测出现问题时更新short-term memory。

long-term 部分是基于关键点匹配和RANSAC的。
long-term记忆的目标外观被记录在一个包含前景与背景的数据库中。利用SIFT描述符，前景记录了SIFT描述符和位置信息，背景记录了SIFT描述符。
除了ICF，short-term还有一部分会持续性地处理长期记忆中的关键点和短期记忆中的关键点。
matcing:用余弦相似度计算每一个描述符的nearest neighbor，设置阈值。并利用最近距离和第二近距离的比值来排除异常点。matching点确定后，就可以找到原始模板中对应的坐标。
forward-backward tracking:分别用t-1时的位置推算t时的位置，t时的位置推算t-1时的位置，比较两个t-1时的位置差，设定阈值。
RANSAC Estimation:在similarity transformation下，目标可以被描述为位置坐标、尺度、旋转角度。
confidence of matching:可以获取内点，内点的数量是判断tracking成功与否的标准之一，设定一个阈值。
occlusion handling:框内的关键点会包含属于背景的部分，还有些目标的关键点会被挡住，两者比值与一个阈值相比，True时表示遮挡发生了。
update the active set:短期记忆每一帧都会更新，若遮挡发生时设置为空集。但是，许多帧的变化不大，会导致集合累计过大，所以要把重复点去掉。

Long-term Memory Updates：
记忆数据库只有在短期处理中显示检测成功并且没有遮挡时才更新，并且不匹配点对于检测变化很重要。
加入了遗忘曲线，当存储空间满了时，进行遗忘。

 Output and Short-term Memory Refreshing：
 当有异常时（检测到遮挡等），输出short-term的结果，否则输出long-term的。并且用输出更新short-term 的滤波器。
 
 # SRDCF
 
 
 # ECO
 
 现有的方法和缺陷：在DCF的基础上，增加多维特征、尺度估计、非线性核、长期记忆模块、负载的学习模型、减少边缘效应。但这些全都牺牲了tracking速度，并有过拟合的风险。
 
影响计算复杂度和过拟合的原因有：模型大小、训练集大小（若丢弃老样本会导致对近期的外观改变过拟合）、模型更新（大多DCF跟踪器会在每一帧进行更新，但最近的成果显示，不需要更新效果也很好）。
 ECO:减少参数、减少训练样本、有效的更新策略
 基础：C-COT:对特征图的大小没有要求；是连续的
 
  Factorized Convolution Operator:
  不对每一个特征都学习单独的滤波器，而是学习数量少于特征数的滤波器，然后进行线性组合。
  Generative Sample Space Model：
  若数量超出限制，会丢弃weight过低的，否则会融合两个最相近的为1个。
  Model Update Strategy：
  只有在足够大的变化发生时才进行更新，由于衡量变化的大小也是很大的计算负担，因此设置每N帧更新一次，并且这样还减少了过拟合的风险。
  
  

# 小结
DSST解决尺度问题，我觉得其实使用的原理其实和位置检测差不多。
MUSTER在很多步骤中都是通过设置阈值来进行判断的，阈值又需要通过经验来设置，我觉得这样工作量挺大的。


# 概念整理
## SIFT
## Lucas-Kanade method
## similarity transformation
## homography transformation
## forgetting curve
## Intersection Over Union


# 问题
## 数学部分
* （DSST）帕塞瓦尔定理
* (DSST）公式4 每个像素点为什么是d* d的计算量
* （ECO）Conjugate Gradient method
## 视觉部分
* （DSST）为什么位置估计时HOG提取出的是2维特征，尺度估计时是1维
 ## 其他
 * （MUSTER）planarity assumption是啥
 *  （MUSTER）3.2 RANSAC部分，st和Pi是什么关系？为什么预测st要用Pi？从这一开始到这一段结尾没看懂。
 *  （MUSTER）3.2 update the active set部分，关键点原来是会累加起来的吗
 *  （MUSTER）3.3 Long-term Memory Updates部分，不匹配点很重要，然后是怎样利用的呢？
 *  （ECO）C-COT的“连续”
 *  （ECO）3.2部分原理